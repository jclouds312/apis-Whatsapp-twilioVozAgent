/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-generated data,
 * including settings, API keys, and workflows, is stored in subcollections under a path specific
 * to that user's ID (`/users/{userId}`). This ensures that users can only access their own data.
 *
 * Data Structure: The data is organized hierarchically. A top-level `/users` collection serves
 * as the root for all user-specific data. A few administrative collections like `/apiLogs`,
 * `/dashboardUsers`, and `/roles` exist at the top level and are inaccessible to clients by default,
 * assuming they are managed by a trusted backend service.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access must be explicitly granted.
 * - Strict Ownership: A user can only read or write data within their own document tree
 *   (i.e., `/users/{request.auth.uid}/...`).
 * - No User Listing: It is not possible for any user to list all documents in the `/users` collection.
 * - Backend-Managed Collections: Collections like `/apiLogs`, `/dashboardUsers`, and `/roles` are
 *   locked down from all client-side access. They are intended for use by backend processes or
 *   administrators with elevated privileges not defined in these rules.
 *
 * Denormalization for Authorization: The rules rely on path-based security, which is a form of
 * denormalization. The user's ID is part of the document path, making ownership checks extremely
 * fast and simple (e.g., `request.auth.uid == userId`) without needing to read other documents
 * using `get()`. For documents created within a user's path, we also enforce that an internal
 * `userId` field matches the path parameter to maintain data integrity.
 *
 * Structural Segregation: The separation of user-specific data into `/users/{userId}` subcollections
 * from global or administrative collections ensures that queries for one type of data cannot
 * inadvertently expose the other. This is a secure and performant design.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the foundation of the user ownership model.
     * @param userId The user ID to check against the authenticated user.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies ownership for an existing resource.
     * CRITICAL: Ensures update/delete operations don't target non-existent documents.
     * @param userId The user ID to check.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On create, validates that the new document's internal userId field
     * matches the userId from the document path.
     * @param userId The user ID from the path.
     */
    function newDocHasCorrectOwner(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * On update, ensures the userId field is immutable.
     */
    function ownerIsImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // User Data
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     * @allow A signed-in user (uid: "user123") creating their own document (at /users/user123). (create)
     * @deny A user ("userABC") trying to read another user's document ("/users/user123"). (get)
     * @principle A user's root document can be created by that user but should be otherwise protected.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users for security.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if false; // User self-deletion should be a backend process.
    }

    /**
     * @description Secures a user's API keys. Only the owner can manage them.
     * @path /users/{userId}/apiKeys/{apiKeyId}
     * @allow User "user123" can create a new API key in their own subcollection. (create)
     * @deny User "userABC" cannot list the API keys of "user123". (list)
     * @principle Enforces strict ownership over sensitive credentials like API keys.
     */
    match /users/{userId}/apiKeys/{apiKeyId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && newDocHasCorrectOwner(userId);
      allow update: if isExistingOwner(userId) && ownerIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures a user's WhatsApp settings. Only the owner can manage them.
     * @path /users/{userId}/whatsappSettings/{whatsappSettingId}
     * @allow User "user123" can update their WhatsApp settings. (update)
     * @deny An anonymous user cannot read any WhatsApp settings. (get)
     * @principle Enforces strict ownership over integration settings.
     */
    match /users/{userId}/whatsappSettings/{whatsappSettingId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && newDocHasCorrectOwner(userId);
      allow update: if isExistingOwner(userId) && ownerIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures a user's Twilio settings. Only the owner can manage them.
     * @path /users/{userId}/twilioSettings/{twilioSettingId}
     * @allow User "user123" can delete their Twilio settings. (delete)
     * @deny User "userABC" cannot create Twilio settings for "user123". (create)
     * @principle Enforces strict ownership over integration settings.
     */
    match /users/{userId}/twilioSettings/{twilioSettingId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && newDocHasCorrectOwner(userId);
      allow update: if isExistingOwner(userId) && ownerIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures a user's CRM endpoints. Only the owner can manage them.
     * @path /users/{userId}/crmEndpoints/{crmEndpointId}
     * @allow User "user123" can list all their configured CRM endpoints. (list)
     * @deny User "userABC" cannot read a specific CRM endpoint of "user123". (get)
     * @principle Enforces strict ownership over integration settings.
     */
    match /users/{userId}/crmEndpoints/{crmEndpointId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && newDocHasCorrectOwner(userId);
      allow update: if isExistingOwner(userId) && ownerIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures connectors nested under a user's CRM endpoint.
     * @path /users/{userId}/crmEndpoints/{crmEndpointId}/connectors/{connectorId}
     * @allow User "user123" can create a connector for their CRM endpoint. (create)
     * @deny User "userABC" cannot update a connector for another user's CRM endpoint. (update)
     * @principle Access is inherited from the parent document's path-based ownership.
     */
    match /users/{userId}/crmEndpoints/{crmEndpointId}/connectors/{connectorId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.crmEndpointId == crmEndpointId;
      allow update: if isExistingOwner(userId) && request.resource.data.crmEndpointId == resource.data.crmEndpointId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures user-specific events. Only the owner can view or manage them.
     * @path /users/{userId}/events/{eventId}
     * @allow User "user123" can read an event document within their own subcollection. (get)
     * @deny An anonymous user cannot create an event for any user. (create)
     * @principle Enforces strict ownership over user-specific audit/event logs.
     */
    match /users/{userId}/events/{eventId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && newDocHasCorrectOwner(userId);
      allow update: if isExistingOwner(userId) && ownerIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures user-defined workflows. Only the owner can manage them.
     * @path /users/{userId}/workflows/{workflowId}
     * @allow User "user123" can create a new workflow for themselves. (create)
     * @deny User "userABC" cannot delete the workflow of "user123". (delete)
     * @principle Enforces strict ownership over a user's created content and logic.
     */
    match /users/{userId}/workflows/{workflowId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && newDocHasCorrectOwner(userId);
      allow update: if isExistingOwner(userId) && ownerIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    // ------------------------------------------------------------------------
    // Backend & Admin Collections (Client Access Denied)
    // ------------------------------------------------------------------------

    /**
     * @description API logs are backend-written and should not be accessible by clients.
     * @path /apiLogs/{apiLogId}
     * @allow No client operation is permitted.
     * @deny Any authenticated user attempting to read an API log. (get)
     * @principle Data written by backend services should be protected from all client access.
     */
    match /apiLogs/{apiLogId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Dashboard user profiles are for admin purposes and should not be client-accessible.
     * @path /dashboardUsers/{dashboardUserId}
     * @allow No client operation is permitted.
     * @deny Any authenticated user attempting to list dashboard users. (list)
     * @principle Administrative data should be protected from all client access.
     */
    match /dashboardUsers/{dashboardUserId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Role definitions are for admin purposes and should not be client-accessible.
     * @path /roles/{roleId}
     * @allow No client operation is permitted.
     * @deny Any authenticated user attempting to create a new role. (create)
     * @principle Administrative data should be protected from all client access.
     */
    match /roles/{roleId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rate limits are tied to API keys but this path structure is not secure for client rules.
     * @path /apiKeys/{apiKeyId}/rateLimits/{rateLimitId}
     * @allow No client operation is permitted.
     * @deny Any user attempting to read a rate limit. (get)
     * @principle This collection is locked down because its path is not nested under `/users/{userId}`,
     * making it impossible to check ownership securely and efficiently without `get()` calls, which is an
     * anti-pattern. This data should be managed by a backend service.
     */
    match /apiKeys/{apiKeyId}/rateLimits/{rateLimitId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}